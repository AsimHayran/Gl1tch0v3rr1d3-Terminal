<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Gl1tch0v3rr1d3 - Interactive hacker-themed terminal interface" />
  <title>Gl1tch0v3rr1d3 Terminal</title>
  <style>
    /* Import fonts */
    @import url("https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap");
    @import url("https://fonts.googleapis.com/css2?family=VT323&display=swap");

    /* CSS Variables for easy theming */
    :root {
      /* Default Green Theme */
      --primary-color: #33FF33;
      --primary-glow: #00ff00;
      --secondary-color: #00FFFF;
      --accent-color: #FF00FF;
      --bg-color: #000;
      --terminal-bg: rgba(0, 0, 0, 0.85);
      --font-main: "Share Tech Mono", monospace;
      --font-pixel: "VT323", monospace;
      
      /* Theme transition */
      transition: all 0.5s ease;
    }
    
    /* Red Theme */
    :root.theme-red {
      --primary-color: #FF3333;
      --primary-glow: #ff0000;
      --secondary-color: #FF9966;
      --accent-color: #FFFF33;
      --bg-color: #000;
      --terminal-bg: rgba(0, 0, 0, 0.85);
    }
    
    /* Blue Theme */
    :root.theme-blue {
      --primary-color: #3333FF;
      --primary-glow: #0000ff;
      --secondary-color: #33CCFF;
      --accent-color: #CC33FF;
      --bg-color: #000;
      --terminal-bg: rgba(0, 0, 0, 0.85);
    }

    /* Accessibility: Focus styles */
    *:focus {
      outline: 2px solid var(--primary-color);
      outline-offset: 2px;
    }

    /* Root styling */
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      background: var(--bg-color);
      color: var(--primary-color);
      font-family: var(--font-main);
      overflow: hidden;
    }

    /* Container for terminal */
    #terminal-container {
      position: relative;
      height: 100vh;
      padding: 2rem;
      box-sizing: border-box;
      user-select: none;
      z-index: 10;
      display: flex;
      flex-direction: column;
    }

    /* Gl1tch0v3rr1d3 Header */
    #header-block {
      white-space: pre;
      font-size: 1.1rem;
      line-height: 1.4;
      margin-bottom: 1.5rem;
      text-shadow:
        0 0 5px var(--primary-color),
        0 0 10px var(--primary-color),
        0 0 20px var(--primary-color),
        0 0 40px var(--primary-glow);
      animation: glitchText 5s infinite;
    }

    /* Terminal output area */
    #terminal {
      white-space: pre-wrap;
      font-size: 1rem;
      line-height: 1.3;
      flex-grow: 1; /* Allow terminal to grow */
      max-height: 60vh; /* Adjust as needed */
      overflow-y: auto;
      border: 1px solid var(--primary-color);
      padding: 1rem;
      background: var(--terminal-bg);
      box-shadow:
        inset 0 0 20px var(--primary-glow),
        0 0 10px var(--primary-glow);
      border-radius: 8px;
      filter: drop-shadow(0 0 5px var(--primary-color));
      position: relative;
      transition: all 0.3s ease;
      margin-bottom: 1rem; /* Space before command area */
    }

    #terminal:hover {
      box-shadow:
        inset 0 0 25px var(--primary-glow),
        0 0 15px var(--primary-glow);
      transform: scale(1.01);
    }

    /* Cursor */
    #cursor {
      display: inline-block;
      width: 10px;
      height: 20px;
      background: var(--primary-color);
      margin-left: 3px;
      animation: blink 1s steps(2, start) infinite;
      vertical-align: bottom;
      filter: drop-shadow(0 0 6px var(--primary-color));
    }

    /* Command input area */
    #command-area {
      display: flex;
      align-items: center;
      margin-top: 1rem;
    }

    #command-input {
      background: transparent;
      border: none;
      color: var(--primary-color);
      font-family: var(--font-main);
      font-size: 1rem;
      flex-grow: 1;
      padding: 0.5rem;
      border-bottom: 1px solid var(--primary-color);
      caret-color: var(--primary-color);
      transition: all 0.3s ease;
    }

    #command-input:focus {
      border-bottom: 2px solid var(--primary-color);
      box-shadow: 0 5px 15px rgba(51, 255, 51, 0.2);
      outline: none;
    }

    /* Command button */
    #command-button {
      background: transparent;
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
      font-family: var(--font-main);
      padding: 0.5rem 1rem;
      margin-left: 0.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    #command-button:hover, #command-button:focus {
      background: rgba(51, 255, 51, 0.2);
      box-shadow: 0 0 10px var(--primary-color);
      transform: translateY(-2px);
    }

    /* Matrix rain canvas overlay */
    #matrix-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 0;
    }

    /* Scanlines overlay */
    #scanlines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 255, 0, 0.05),
        rgba(0, 255, 0, 0.05) 2px,
        rgba(0, 255, 0, 0.1) 3px,
        rgba(0, 255, 0, 0.05) 4px
      );
      animation: scanPulse 4s ease-in-out infinite;
      mix-blend-mode: screen;
      z-index: 1;
    }

    /* Progress bar container */
    .progress-container {
      width: 100%;
      height: 20px;
      background-color: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--primary-color);
      margin: 10px 0;
      position: relative;
      overflow: hidden;
    }

    /* Progress bar */
    .progress-bar {
      height: 100%;
      width: 0%;
      background-color: var(--primary-color);
      position: relative;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px var(--primary-color);
    }

    /* Progress bar text */
    .progress-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--bg-color);
      font-weight: bold;
      mix-blend-mode: difference;
    }

    /* Digital pet container */
    #pet-container {
      position: absolute;
      bottom: 40px;
      right: 40px;
      width: 100px;
      height: 100px;
      z-index: 100;
      cursor: pointer;
      transition: all 0.5s ease;
      filter: drop-shadow(0 0 10px var(--primary-glow));
    }

    /* Cybernetic Pet Styling */
    #pet {
      width: 100%;
      height: 100%;
      position: relative;
      transition: all 0.5s ease;
      transform-origin: center;
    }

    /* Pet Head */
    .pet-head {
      position: absolute;
      width: 70px;
      height: 70px;
      top: 5px;
      left: 15px;
      background-color: rgba(0, 0, 0, 0.7);
      border: 2px solid var(--primary-color);
      border-radius: 15px;
      box-shadow: 0 0 10px var(--primary-glow);
      overflow: hidden;
    }

    /* Pet Circuit Lines */
    .pet-circuit {
      position: absolute;
      background-color: var(--primary-color);
      opacity: 0.7;
    }

    .pet-circuit-1 {
      width: 30px;
      height: 2px;
      top: 15px;
      left: 5px;
    }

    .pet-circuit-2 {
      width: 2px;
      height: 20px;
      top: 15px;
      left: 35px;
    }

    .pet-circuit-3 {
      width: 20px;
      height: 2px;
      top: 35px;
      left: 35px;
    }

    .pet-circuit-4 {
      width: 2px;
      height: 15px;
      top: 35px;
      left: 55px;
    }

    /* Pet Eyes */
    .pet-eye {
      position: absolute;
      width: 15px;
      height: 15px;
      background-color: var(--primary-color);
      border-radius: 3px;
      top: 25px;
      box-shadow: 0 0 8px var(--primary-color);
      animation: eyeBlink 3s infinite;
    }

    .pet-eye.left {
      left: 15px;
    }

    .pet-eye.right {
      right: 15px;
    }

    /* Pet Mouth */
    .pet-mouth {
      position: absolute;
      width: 30px;
      height: 10px;
      border-bottom: 3px solid var(--primary-color);
      border-radius: 5px;
      bottom: 15px;
      left: 20px;
      box-shadow: 0 0 8px var(--primary-color);
      transition: all 0.3s ease;
    }
    
    /* Pet Expressions */
    .pet-mouth.happy {
      border-radius: 0 0 10px 10px;
      height: 15px;
      width: 25px;
      left: 22px;
    }
    
    .pet-mouth.sad {
      border-radius: 10px 10px 0 0;
      border-bottom: none;
      border-top: 3px solid var(--primary-color);
      bottom: 10px;
    }
    
    .pet-mouth.surprised {
      height: 15px;
      width: 15px;
      border: 3px solid var(--primary-color);
      border-radius: 50%;
      left: 27px;
    }
    
    .pet-mouth.angry {
      transform: rotate(45deg);
      width: 20px;
      left: 25px;
    }
    
    .pet-eye.alert {
      background-color: var(--accent-color);
      box-shadow: 0 0 8px var(--accent-color);
    }
    
    .pet-eye.happy {
      border-radius: 50% 50% 0 0;
      height: 10px;
    }
    
    .pet-eye.suspicious {
      height: 8px;
      width: 18px;
    }

    /* Pet Antenna */
    .pet-antenna {
      position: absolute;
      width: 2px;
      height: 15px;
      background-color: var(--primary-color);
      top: -15px;
      left: 35px;
      box-shadow: 0 0 8px var(--primary-color);
    }

    .pet-antenna-tip {
      position: absolute;
      width: 6px;
      height: 6px;
      background-color: var(--primary-color);
      border-radius: 50%;
      top: -18px;
      left: 33px;
      box-shadow: 0 0 8px var(--primary-color);
      animation: pulse 2s infinite;
    }

    /* Pet Body */
    .pet-body {
      position: absolute;
      width: 40px;
      height: 20px;
      bottom: 0;
      left: 30px;
      background-color: rgba(0, 0, 0, 0.7);
      border: 2px solid var(--primary-color);
      border-radius: 5px;
      box-shadow: 0 0 10px var(--primary-glow);
    }

    /* Pet Legs */
    .pet-leg {
      position: absolute;
      width: 3px;
      height: 12px;
      background-color: var(--primary-color);
      bottom: -10px;
      box-shadow: 0 0 8px var(--primary-color);
    }

    .pet-leg.left-front {
      left: 33px;
      animation: legMove 0.5s infinite alternate;
    }

    .pet-leg.right-front {
      left: 43px;
      animation: legMove 0.5s infinite alternate-reverse;
    }

    .pet-leg.left-back {
      left: 53px;
      animation: legMove 0.5s infinite alternate-reverse;
    }

    .pet-leg.right-back {
      left: 63px;
      animation: legMove 0.5s infinite alternate;
    }

    /* Pet Speech Bubble */
    .pet-speech {
      position: absolute;
      min-width: 120px;
      max-width: 200px;
      padding: 10px;
      background-color: var(--terminal-bg);
      border: 1px solid var(--primary-color);
      border-radius: 10px;
      color: var(--primary-color);
      font-family: var(--font-pixel);
      font-size: 14px;
      bottom: 110px;
      right: 20px;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
      box-shadow: 0 0 15px var(--primary-glow);
      z-index: 101;
      pointer-events: auto; /* Enable interactions */
      display: flex;
      flex-direction: column;
    }

    .pet-speech-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
    }

    .pet-speech-close {
      color: var(--primary-color);
      cursor: pointer;
      font-size: 16px;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--primary-color);
      border-radius: 3px;
      transition: all 0.2s ease;
    }

    .pet-speech-close:hover {
      background-color: rgba(51, 255, 51, 0.2);
      transform: scale(1.1);
    }

    .pet-speech-content {
      width: 100%;
    }

    .pet-speech:after {
      content: "";
      position: absolute;
      bottom: -10px;
      right: 30px;
      border-width: 10px 10px 0;
      border-style: solid;
      border-color: var(--primary-color) transparent;
    }

    .pet-speech.show {
      opacity: 1;
      transform: translateY(0);
    }

    /* Pet Pixel Grid Overlay */
    .pet-pixel-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(rgba(51, 255, 51, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(51, 255, 51, 0.1) 1px, transparent 1px);
      background-size: 4px 4px;
      pointer-events: none;
    }

    /* Pet interaction menu */
    #pet-menu {
      position: absolute;
      bottom: 110px;
      right: 40px;
      background-color: var(--terminal-bg);
      border: 1px solid var(--primary-color);
      border-radius: 5px;
      padding: 10px;
      display: none;
      box-shadow: 0 0 15px var(--primary-glow);
      z-index: 101;
    }

    .pet-action {
      color: var(--primary-color);
      padding: 5px 10px;
      margin: 5px 0;
      cursor: pointer;
      transition: all 0.3s ease;
      border-radius: 3px;
      font-family: var(--font-pixel);
    }

    .pet-action:hover {
      background-color: rgba(51, 255, 51, 0.2);
      transform: translateX(5px);
    }

    /* Status bar */
    #status-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: var(--terminal-bg);
      color: var(--primary-color);
      padding: 5px 10px;
      font-size: 0.8rem;
      border-top: 1px solid var(--primary-color);
      display: flex;
      justify-content: space-between;
      z-index: 50;
      box-sizing: border-box;
    }

    #status-indicator {
      width: 10px;
      height: 10px;
      background-color: var(--primary-color);
      border-radius: 50%;
      display: inline-block;
      margin-right: 5px;
      animation: pulse 2s infinite;
    }

    /* Snake Game Styles */
    #snake-game {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--terminal-bg);
      border: 2px solid var(--primary-color);
      box-shadow: 0 0 20px var(--primary-glow);
      padding: 10px;
      z-index: 200;
      flex-direction: column;
      align-items: center;
    }
    
    #snake-canvas {
      border: 1px solid var(--primary-color);
      background-color: rgba(0, 0, 0, 0.8);
      margin-bottom: 10px;
    }
    
    #snake-score {
      color: var(--primary-color);
      font-family: var(--font-pixel);
      font-size: 1.2rem;
      margin-bottom: 10px;
    }
    
    #snake-controls {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin-top: 10px;
    }
    
    .snake-btn {
      background: transparent;
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
      font-family: var(--font-main);
      padding: 5px 10px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .snake-btn:hover {
      background: rgba(51, 255, 51, 0.2);
      box-shadow: 0 0 10px var(--primary-color);
    }

    /* Animations */
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    @keyframes eyeBlink {
      0%, 45%, 55%, 100% { opacity: 1; height: 15px; }
      50% { opacity: 0.5; height: 2px; }
    }

    @keyframes scanPulse {
      0%, 100% { opacity: 0.08; }
      50% { opacity: 0.15; }
    }

    @keyframes pulse {
      0%, 100% { 
        transform: scale(1);
        opacity: 1;
      }
      50% { 
        transform: scale(1.2);
        opacity: 0.7;
      }
    }

    @keyframes legMove {
      0% { transform: rotate(-15deg); }
      100% { transform: rotate(15deg); }
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    @keyframes glitchText {
      0%, 100% { 
        text-shadow:
          0 0 5px var(--primary-color),
          0 0 10px var(--primary-color),
          0 0 20px var(--primary-color),
          0 0 40px var(--primary-glow);
      }
      25% {
        text-shadow:
          -2px 0 5px var(--accent-color),
          2px 2px 10px var(--secondary-color),
          0 0 20px var(--primary-color),
          0 0 40px var(--primary-glow);
        transform: skew(0.5deg, 0.5deg);
      }
      26% {
        text-shadow:
          0 0 5px var(--primary-color),
          0 0 10px var(--primary-color),
          0 0 20px var(--primary-color),
          0 0 40px var(--primary-glow);
        transform: skew(0deg, 0deg);
      }
      50% {
        text-shadow:
          0 0 5px var(--primary-color),
          0 0 10px var(--primary-color),
          0 0 20px var(--primary-color),
          0 0 40px var(--primary-glow);
      }
      75% {
        text-shadow:
          1px -1px 5px var(--accent-color),
          -1px 1px 10px var(--secondary-color),
          0 0 20px var(--primary-color),
          0 0 40px var(--primary-glow);
        transform: skew(-0.5deg, -0.5deg);
      }
      76% {
        text-shadow:
          0 0 5px var(--primary-color),
          0 0 10px var(--primary-color),
          0 0 20px var(--primary-color),
          0 0 40px var(--primary-glow);
        transform: skew(0deg, 0deg);
      }
    }

    @keyframes glitch {
      0%, 100% { opacity: 0; }
      5%, 10% { opacity: 0.8; transform: translate(-5px, 0); }
      15% { opacity: 0; }
      20%, 25% { opacity: 0.6; transform: translate(5px, 0); }
      30% { opacity: 0; }
      45%, 50% { opacity: 0.4; transform: translate(0, -3px); }
      55% { opacity: 0; }
    }

    /* Accessibility improvements */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    /* Media queries for responsiveness */
    @media (max-width: 768px) {
      #terminal-container {
        padding: 1rem;
        height: 100vh;
        width: 100vw;
        box-sizing: border-box;
      }
      
      #header-block {
        font-size: 0.7rem;
        margin-bottom: 1rem;
      }
      
      #terminal {
        max-height: none; /* Allow terminal to take available space */
        flex-grow: 1;
      }
      
      #command-area {
        margin-top: 0.5rem;
      }
      
      #pet-container {
        width: 80px;
        height: 80px;
        bottom: 60px;
        right: 20px;
      }
      
      .pet-speech {
        max-width: 150px;
        font-size: 12px;
        bottom: 140px;
        right: 10px;
      }
      
      #status-bar {
        padding: 3px 5px;
        font-size: 0.7rem;
      }
    }

    @media (max-width: 480px) {
      #terminal-container {
        padding: 0.5rem;
      }
      
      #header-block {
        font-size: 0.5rem;
        margin-bottom: 0.5rem;
      }
      
      #terminal {
        padding: 0.5rem;
      }
      
      #command-input {
        font-size: 0.9rem;
      }
      
      #command-button {
        padding: 0.4rem 0.8rem;
        font-size: 0.9rem;
      }
      
      #pet-container {
        width: 60px;
        height: 60px;
        bottom: 50px;
        right: 10px;
      }
    }
  </style>
</head>
<body>
  <!-- Screen reader announcement area -->
  <div aria-live="polite" id="screen-reader-announcer" class="sr-only"></div>

  <!-- Matrix background -->
  <canvas id="matrix-canvas" aria-hidden="true"></canvas>
  
  <!-- Scanlines -->
  <div id="scanlines" aria-hidden="true"></div>
  
  <!-- Glitch overlay -->
  <div id="glitch-overlay" aria-hidden="true"></div>

  <div id="terminal-container" role="main" aria-label="Gl1tch0v3rr1d3 Terminal">
    <div id="header-block" aria-label="Gl1tch0v3rr1d3 Header" role="region" tabindex="0">
      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
      ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
      ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë        ‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  
      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  
      ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
       ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    </div>

    <div id="terminal" aria-live="polite" aria-label="Gl1tch0v3rr1d3 terminal output" tabindex="0">
      <span id="cursor" aria-hidden="true"></span>
    </div>

    <div class="progress-container" aria-label="System loading progress" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
      <div class="progress-bar" id="main-progress">
        <div class="progress-text">0%</div>
      </div>
    </div>

    <!-- Command Input Area -->
    <div id="command-area" role="form" aria-label="Terminal command input">
      <label for="command-input" class="sr-only">Enter command</label>
      <input type="text" id="command-input" placeholder="Enter command..." aria-label="Command input field" disabled />
      <button id="command-button" aria-label="Execute command" disabled>Execute</button>
    </div>
  </div>

  <!-- Digital pet -->
  <div id="pet-container" tabindex="0" aria-label="Digital pet assistant" role="button">
    <div id="pet">
      <div class="pet-head">
        <div class="pet-circuit pet-circuit-1"></div>
        <div class="pet-circuit pet-circuit-2"></div>
        <div class="pet-circuit pet-circuit-3"></div>
        <div class="pet-circuit pet-circuit-4"></div>
        <div class="pet-eye left"></div>
        <div class="pet-eye right"></div>
        <div class="pet-mouth"></div>
        <div class="pet-antenna"></div>
        <div class="pet-antenna-tip"></div>
      </div>
      <div class="pet-body"></div>
      <div class="pet-leg left-front"></div>
      <div class="pet-leg right-front"></div>
      <div class="pet-leg left-back"></div>
      <div class="pet-leg right-back"></div>
      <div class="pet-pixel-overlay"></div>
    </div>
  </div>

  <!-- Pet speech bubble -->
  <div class="pet-speech" id="pet-speech" aria-live="polite">
    <div class="pet-speech-header">
      <div class="pet-speech-title"></div>
      <div class="pet-speech-close" role="button" aria-label="Close message" tabindex="0">√ó</div>
    </div>
    <div class="pet-speech-content"></div>
  </div>

  <!-- Pet interaction menu -->
  <div id="pet-menu" role="menu" aria-label="Pet interaction options">
    <div class="pet-action" role="menuitem" tabindex="0" data-action="help">Ask for help</div>
    <div class="pet-action" role="menuitem" tabindex="0" data-action="hack">Hack assistance</div>
    <div class="pet-action" role="menuitem" tabindex="0" data-action="play">Play with pet</div>
    <div class="pet-action" role="menuitem" tabindex="0" data-action="hide">Hide pet</div>
  </div>

  <!-- Snake Game Container -->
  <div id="snake-game" role="dialog" aria-label="Snake mini-game">
    <div id="snake-score">Score: 0</div>
    <canvas id="snake-canvas" width="300" height="300" aria-label="Snake game area"></canvas>
    <div id="snake-controls">
      <button class="snake-btn" id="snake-pause">Pause</button>
      <button class="snake-btn" id="snake-exit">Exit Game</button>
    </div>
  </div>

  <script>
    // Accessibility announcer function
    function announce(message) {
      const announcer = document.getElementById("screen-reader-announcer");
      announcer.textContent = message;
    }

    // Matrix rain effect
    const canvas = document.getElementById("matrix-canvas");
    const ctx = canvas.getContext("2d");

    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    const katakana = "ÔΩ±ÔΩ≤ÔΩ≥ÔΩ¥ÔΩµÔΩ∂ÔΩ∑ÔΩ∏ÔΩπÔΩ∫ÔΩªÔΩºÔΩΩÔΩæÔΩøÔæÄÔæÅÔæÇÔæÉÔæÑÔæÖÔæÜÔæáÔæàÔæâÔæäÔæãÔæåÔæçÔæéÔæèÔæêÔæëÔæíÔæìÔæîÔæïÔæñÔæóÔæòÔæôÔæöÔæõÔæúÔæù0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const fontSize = 16;
    let columns = Math.floor(width / fontSize);

    const drops = new Array(columns).fill(1);

    function drawMatrix() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = "#33ff33";
      ctx.font = `${fontSize}px 'Share Tech Mono', monospace`;

      for (let i = 0; i < drops.length; i++) {
        const text = katakana.charAt(Math.floor(Math.random() * katakana.length));
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);

        if (drops[i] * fontSize > height && Math.random() > 0.975) {
          drops[i] = 0;
        }
        drops[i]++;
      }
    }

    window.addEventListener("resize", () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      columns = Math.floor(width / fontSize);

      // Reset drops array with proper length
      drops.length = columns;
      for (let i = 0; i < columns; i++) {
        drops[i] = 1;
      }
    });

    setInterval(drawMatrix, 50);

    // Glitch effect function
    function triggerGlitch() {
      const glitchOverlay = document.getElementById("glitch-overlay");
      glitchOverlay.style.opacity = "1";
      
      // Random glitch position
      const xPos = Math.random() * 100;
      const yPos = Math.random() * 100;
      
      glitchOverlay.style.background = `
        linear-gradient(
          ${Math.random() * 360}deg,
          rgba(51, 255, 51, ${Math.random() * 0.3}),
          transparent ${50 + Math.random() * 20}%
        )
      `;
      
      setTimeout(() => {
        glitchOverlay.style.opacity = "0";
      }, 150);
    }

    // Periodically trigger glitch effects
    setInterval(triggerGlitch, 3000 + Math.random() * 5000);

    // Terminal typing effect
    const terminal = document.getElementById("terminal");
    const cursor = document.getElementById("cursor");

    const lines = [
      "void@root ~",
      "‚îî‚îÄ$ sudo kill -9 $(pgrep -u ü´µ) --0xdeadbeef --overwrite --darknet-flush --final-breach",
      "[ü´µ.nullified] // access revoked, shadows fragmented, no backups, no mercy",
      "",
      "--==[ùîæùïùùüôùï•ùïîùïôùüòùïßùüõùï£ùï£ùüôùïïùüõ v.0xùüºùüπùüπ | œÉ ú‚àÇœâ Ä·¥è·¥è·¥õ17]==--",
      "--==[payload: %bTn>7j@vP$e0>yF`f;!F$LS]#d;Oz1^Vkx*6/4r;#&<|U3A,,zVKUp9j+]<P",
      "--==[checksum: MzY3ZTQ4ZjUyYTIxNjU4NjNkZjEzZjZmYzMyYmNmMzY= | eol]==--",
      "",
      "Initializing system..."
    ];

    let lineIndex = 0;
    let charIndex = 0;

    function typeLine() {
      if (lineIndex >= lines.length) {
        cursor.style.display = "none";
        startProgressBar();
        return;
      }

      const line = lines[lineIndex];
      if (charIndex < line.length) {
        terminal.textContent += line.charAt(charIndex);
        charIndex++;
        terminal.scrollTop = terminal.scrollHeight; // keep scroll down
        setTimeout(typeLine, 40);
      } else {
        terminal.textContent += "\n";
        terminal.scrollTop = terminal.scrollHeight; // keep scroll down
        lineIndex++;
        charIndex = 0;
        setTimeout(typeLine, 600);
      }
    }

    // Progress bar animation
    function startProgressBar() {
      const progressBar = document.getElementById("main-progress");
      const progressText = progressBar.querySelector(".progress-text");
      let progress = 0;
      
      const progressInterval = setInterval(() => {
        progress += Math.random() * 5;
        if (progress > 100) progress = 100;
        
        progressBar.style.width = `${progress}%`;
        progressText.textContent = `${Math.floor(progress)}%`;
        
        // Update ARIA attributes for accessibility
        progressBar.parentElement.setAttribute("aria-valuenow", Math.floor(progress));
        
        if (progress === 100) {
          clearInterval(progressInterval);
          setTimeout(() => {
            addTerminalLine("System initialized successfully.");
            addTerminalLine("Gl1tch0v3rr1d3 terminal ready.");
            addTerminalLine("Type \"help\" for available commands.");
            announce("System initialized. Command input is now available.");
            enableCommandInput(); // Enable command input here
            activatePet();
          }, 500);
        }
      }, 200);
    }

    // Add a line to the terminal
    function addTerminalLine(text) {
      const terminalContent = terminal.textContent;
      terminal.textContent = terminalContent + "\n" + text;
      terminal.scrollTop = terminal.scrollHeight;
    }

    // Enable command input after initialization
    function enableCommandInput() {
      const commandInput = document.getElementById("command-input");
      const commandButton = document.getElementById("command-button");
      
      commandInput.disabled = false;
      commandButton.disabled = false;
      
      // Focus on input
      commandInput.focus();
      
      // Add event listeners
      commandButton.addEventListener("click", executeCommand);
      commandInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          executeCommand();
        }
      });
    }

    // Comma    // Execute command
    function executeCommand() {
      const commandInput = document.getElementById("command-input");
      const command = commandInput.value.trim();
      
      if (command === "") return;
      
      // Add command to terminal
      addTerminalLine(`void@root ~ ‚îî ${command}`);
      
      // Add to command history
      addToCommandHistory(command);
      
      // Process command
      processCommand(command);
      
      // Clear input
      commandInput.value = "";
      commandInput.focus();
    }    // Command processor
    function processCommand(command) {
      // Trigger glitch effect on command execution
      triggerGlitch();
      
      // Pet reaction to commands
      if (petVisible) {
        reactToPetCommand(command);
      }
      
      // Easter egg: BSOD for dangerous command
      if (command === "sudo rm -rf /" || command === "sudo rm -rf /*") {
        showBSOD();
        return;
      }
      
      // Easter egg: Hidden backdoor
      if (command === "override_access --silent" || command === "backdoor") {
        showBackdoorAccess();
        return;
      }
      
      // Theme switching commands
      if (command === "theme --red") {
        setTheme("red");
        addTerminalLine("Theme switched to RED");
        return;
      }
      
      if (command === "theme --blue") {
        setTheme("blue");
        addTerminalLine("Theme switched to BLUE");
        return;
      }
      
      if (command === "theme --green" || command === "theme --default") {
        setTheme("default");
        addTerminalLine("Theme switched to DEFAULT (green)");
        return;
      }
      
      // Pet game command
      if (command === "pet --game=snake") {
        startSnakeGame();
        return;
      }
      
      switch(command) {
        case "help":
          addTerminalLine("Available commands:");
          addTerminalLine("  help       - Show this help message");
          addTerminalLine("  clear      - Clear terminal");
          addTerminalLine("  status     - Show system status");
          addTerminalLine("  scan       - Scan for vulnerabilities");
          addTerminalLine("  hack       - Attempt to hack the system");
          addTerminalLine("  matrix     - Toggle matrix rain effect");
          addTerminalLine("  glitch     - Trigger glitch effect");
          addTerminalLine("  pet        - Toggle digital pet");
          addTerminalLine("  whoami     - Display current user");
          addTerminalLine("  theme --red/--blue/--green - Switch color theme");
          addTerminalLine("  pet --game=snake - Play Snake mini-game");
          break;
          
        case "clear":
          terminal.textContent = "";
          announce("Terminal cleared");
          break;
          
        case "status":
          addTerminalLine("System Status:");
          addTerminalLine("  CPU: 32% | Memory: 1.2GB/4GB | Network: Active");
          addTerminalLine("  Security Level: Maximum");
          addTerminalLine("  Encryption: AES-256");
          addTerminalLine("  Last Login: " + new Date().toLocaleString());
          break;
          
        case "scan":
          addTerminalLine("Initiating vulnerability scan...");
          runProgressOperation("Scanning system", () => {
            addTerminalLine("Scan complete. Results:");
            addTerminalLine("  Found 3 potential vulnerabilities:");
            addTerminalLine("  - CVE-2023-1337: Medium risk");
            addTerminalLine("  - PORT-22: SSH exposed");
            addTerminalLine("  - USER-ADMIN: Default credentials");
            addTerminalLine("  - you are hacked by ShadowRoot17");
          });
          break;
          
        case "hack":
          addTerminalLine("UNAUTHORIZED ACCESS ATTEMPT DETECTED");
          addTerminalLine("SECURITY PROTOCOLS ENGAGED");
          
          // Multiple glitch effects
          for (let i = 0; i < 5; i++) {
            setTimeout(triggerGlitch, i * 200);
          }
          
          setTimeout(() => {
            addTerminalLine("Access denied. This incident has been reported.");
          }, 1500);
          break;
          
        case "matrix":
          const matrixCanvas = document.getElementById("matrix-canvas");
          if (matrixCanvas.style.display === "none") {
            matrixCanvas.style.display = "block";
            addTerminalLine("Matrix rain effect enabled.");
          } else {
            matrixCanvas.style.display = "none";
            addTerminalLine("Matrix rain effect disabled.");
          }
          break;
          
        case "glitch":
          addTerminalLine("Triggering system glitch...");
          
          // Multiple intense glitch effects
          for (let i = 0; i < 10; i++) {
            setTimeout(triggerGlitch, i * 100);
          }
          
          setTimeout(() => {
            addTerminalLine("Glitch sequence complete.");
          }, 1500);
          break;
          
        case "pet":
          const petContainer = document.getElementById("pet-container");
          if (petContainer.style.display === "none") {
            petVisible = true;
            petContainer.style.display = "block";
            addTerminalLine("Digital pet activated.");
            activatePet(); // Restart pet functions
          } else {
            petVisible = false;
            petContainer.style.display = "none";
            addTerminalLine("Digital pet deactivated.");
          }
          break;
          
        case "whoami":
          addTerminalLine("Current user: Human");
          addTerminalLine("Access level: 0%");
          addTerminalLine("Session: " + Math.random().toString(36).substring(2, 15));
          break;
          
        // Easter egg: Hidden command
        case "matrix reloaded":
          addTerminalLine("Entering the Matrix...");
          document.body.style.animation = "glitch 0.3s infinite";
          setTimeout(() => {
            document.body.style.animation = "";
            addTerminalLine("ShadowRoot17 have been messing with you...");
            addTerminalLine(" Plz cloes the tab.");
          }, 3000);
          break;
          
        // Easter egg: Hidden command
        case "42":
          addTerminalLine("The Answer to the Ultimate Question of Life, the Universe, and Everything, or you just got hacked by ShadowRoot17.");
          break;
          
        default:
          addTerminalLine(`Command not recognized: ${command}`);
          addTerminalLine("Type \"help\" for available commands.");
      }
    }
    
    // Pet reaction to commands
    function reactToPetCommand(command) {
      const petMouth = document.querySelector(".pet-mouth");
      const petEyes = document.querySelectorAll(".pet-eye");
      
      // Reset previous expressions
      petMouth.className = "pet-mouth";
      petEyes.forEach(eye => eye.className = eye.classList.contains("left") ? "pet-eye left" : "pet-eye right");
      
      // Jump animation for certain commands
      if (["hack", "glitch", "scan"].includes(command)) {
        pet.style.animation = "float 0.5s ease-in-out";
        setTimeout(() => {
          pet.style.animation = "";
        }, 500);
      }
      
      // Command-specific reactions
      switch(command) {
        case "hack":
          petMouth.classList.add("surprised");
          petEyes.forEach(eye => eye.classList.add("alert"));
          showPetSpeech("Unauthorized access detected!", "Alert");
          break;
          
        case "scan":
          petMouth.classList.add("suspicious");
          petEyes.forEach(eye => eye.classList.add("suspicious"));
          showPetSpeech("Scanning for vulnerabilities...", "Scan");
          break;
          
        case "clear":
          petMouth.classList.add("happy");
          petEyes.forEach(eye => eye.classList.add("happy"));
          break;
          
        case "sudo rm -rf /":
        case "sudo rm -rf /*":
          petMouth.classList.add("surprised");
          petEyes.forEach(eye => eye.classList.add("alert"));
          showPetSpeech("DANGER! System critical command detected!", "WARNING");
          break;
          
        case "help":
          petMouth.classList.add("happy");
          break;
          
        case "matrix":
          petEyes.forEach(eye => eye.classList.add("suspicious"));
          break;
          
        case "glitch":
          petMouth.classList.add("surprised");
          break;
          
        case "backdoor":
        case "override_access --silent":
          petMouth.classList.add("surprised");
          petEyes.forEach(eye => eye.classList.add("alert"));
          showPetSpeech("Backdoor access detected!", "SECURITY BREACH");
          break;
      }
    }
    
    // Theme switching function
    function setTheme(theme) {
      const root = document.documentElement;
      
      // Remove any existing theme classes
      root.classList.remove('theme-red', 'theme-blue');
      
      // Add the appropriate theme class
      if (theme === 'red') {
        root.classList.add('theme-red');
      } else if (theme === 'blue') {
        root.classList.add('theme-blue');
      }
      // Default theme (green) has no class
      
      // Update matrix color based on theme
      updateMatrixColor(theme);
      
      // Announce theme change for screen readers
      announce(`Theme changed to ${theme}`);
    }
    
    // Update matrix rain color based on theme
    function updateMatrixColor(theme) {
      let color;
      switch(theme) {
        case 'red':
          color = '#FF3333';
          break;
        case 'blue':
          color = '#3333FF';
          break;
        default:
          color = '#33FF33';
      }
      
      // Update matrix color in the drawMatrix function
      matrixColor = color;
    }
    // Snake Game Implementation
    let snakeGame = {
      canvas: null,
      ctx: null,
      snake: [],
      food: null,
      direction: 'right',
      nextDirection: 'right',
      gameSpeed: 100,
      tileSize: 10,
      gameLoopInterval: null,
      score: 0,
      isPaused: false,
      
      // Initialize the game
      init: function() {
        this.canvas = document.getElementById('snake-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resetGame();
        this.setupEventListeners();
        this.gameLoop();
      },
      
      // Reset game state
      resetGame: function() {
        this.snake = [
          {x: 10, y: 10},
          {x: 9, y: 10},
          {x: 8, y: 10}
        ];
        this.generateFood();
        this.direction = 'right';
        this.nextDirection = 'right';
        this.score = 0;
        this.updateScore();
        this.isPaused = false;
        document.getElementById('snake-pause').textContent = 'Pause';
      },
      
      // Generate food at random position
      generateFood: function() {
        const maxX = Math.floor(this.canvas.width / this.tileSize) - 1;
        const maxY = Math.floor(this.canvas.height / this.tileSize) - 1;
        
        // Generate random position
        let foodX = Math.floor(Math.random() * maxX) + 1;
        let foodY = Math.floor(Math.random() * maxY) + 1;
        
        // Check if food is on snake
        let onSnake = false;
        for (let i = 0; i < this.snake.length; i++) {
          if (this.snake[i].x === foodX && this.snake[i].y === foodY) {
            onSnake = true;
            break;
          }
        }
        
        // If food is on snake, generate again
        if (onSnake) {
          this.generateFood();
        } else {
          this.food = {x: foodX, y: foodY};
        }
      },
      
      // Update score display
      updateScore: function() {
        document.getElementById('snake-score').textContent = `Score: ${this.score}`;
      },
      
      // Main game loop
      gameLoop: function() {
        if (this.gameLoopInterval) {
          clearInterval(this.gameLoopInterval);
        }
        
        this.gameLoopInterval = setInterval(() => {
          if (!this.isPaused) {
            this.update();
            this.draw();
          }
        }, this.gameSpeed);
      },
      
      // Update game state
      update: function() {
        // Update direction
        this.direction = this.nextDirection;
        
        // Create new head based on direction
        const head = {x: this.snake[0].x, y: this.snake[0].y};
        
        switch(this.direction) {
          case 'up':
            head.y -= 1;
            break;
          case 'down':
            head.y += 1;
            break;
          case 'left':
            head.x -= 1;
            break;
          case 'right':
            head.x += 1;
            break;
        }
        
        // Check for collisions
        if (this.checkCollision(head)) {
          this.gameOver();
          return;
        }
        
        // Add new head
        this.snake.unshift(head);
        
        // Check if snake ate food
        if (head.x === this.food.x && head.y === this.food.y) {
          this.score += 10;
          this.updateScore();
          this.generateFood();
        } else {
          // Remove tail if no food eaten
          this.snake.pop();
        }
      },
      
      // Check for collisions
      checkCollision: function(head) {
        // Check wall collision
        if (head.x < 0 || head.y < 0 || 
            head.x >= this.canvas.width / this.tileSize || 
            head.y >= this.canvas.height / this.tileSize) {
          return true;
        }
        
        // Check self collision
        for (let i = 0; i < this.snake.length; i++) {
          if (this.snake[i].x === head.x && this.snake[i].y === head.y) {
            return true;
          }
        }
        
        return false;
      },
      
      // Game over
      gameOver: function() {
        clearInterval(this.gameLoopInterval);
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
        this.ctx.font = '20px "VT323", monospace';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 10);
        this.ctx.fillText(`Score: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 20);
        this.ctx.fillText('Press any key to restart', this.canvas.width / 2, this.canvas.height / 2 + 50);
        
        // Set up one-time event listener for restart
        const restartHandler = (e) => {
          this.resetGame();
          this.gameLoop();
          window.removeEventListener('keydown', restartHandler);
        };
        
        window.addEventListener('keydown', restartHandler);
      },
      
      // Draw game state
      draw: function() {
        // Clear canvas
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw snake
        const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
        this.ctx.fillStyle = primaryColor;
        
        for (let i = 0; i < this.snake.length; i++) {
          this.ctx.fillRect(
            this.snake[i].x * this.tileSize, 
            this.snake[i].y * this.tileSize, 
            this.tileSize, 
            this.tileSize
          );
          
          // Add pixel effect to snake
          this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
          this.ctx.strokeRect(
            this.snake[i].x * this.tileSize, 
            this.snake[i].y * this.tileSize, 
            this.tileSize, 
            this.tileSize
          );
        }
        
        // Draw food
        const secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color');
        this.ctx.fillStyle = secondaryColor;
        this.ctx.fillRect(
          this.food.x * this.tileSize, 
          this.food.y * this.tileSize, 
          this.tileSize, 
          this.tileSize
        );
        
        // Add glow effect to food
        this.ctx.shadowColor = secondaryColor;
        this.ctx.shadowBlur = 10;
        this.ctx.fillRect(
          this.food.x * this.tileSize, 
          this.food.y * this.tileSize, 
          this.tileSize, 
          this.tileSize
        );
        this.ctx.shadowBlur = 0;
      },
      
      // Set up event listeners
      setupEventListeners: function() {
        // Keyboard controls
        window.addEventListener('keydown', (e) => {
          if (!this.isPaused) {
            switch(e.key) {
              case 'ArrowUp':
                if (this.direction !== 'down') {
                  this.nextDirection = 'up';
                }
                break;
              case 'ArrowDown':
                if (this.direction !== 'up') {
                  this.nextDirection = 'down';
                }
                break;
              case 'ArrowLeft':
                if (this.direction !== 'right') {
                  this.nextDirection = 'left';
                }
                break;
              case 'ArrowRight':
                if (this.direction !== 'left') {
                  this.nextDirection = 'right';
                }
                break;
            }
          }
          
          // Prevent arrow keys from scrolling the page
          if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
          }
        });
        
        // Pause button
        document.getElementById('snake-pause').addEventListener('click', () => {
          this.isPaused = !this.isPaused;
          document.getElementById('snake-pause').textContent = this.isPaused ? 'Resume' : 'Pause';
        });
        
        // Exit button
        document.getElementById('snake-exit').addEventListener('click', () => {
          clearInterval(this.gameLoopInterval);
          document.getElementById('snake-game').style.display = 'none';
          addTerminalLine("Snake game exited. Final score: " + this.score);
        });
      }
    };
    
    // Start Snake Game
    function startSnakeGame() {
      addTerminalLine("Starting Snake mini-game...");
      addTerminalLine("Use arrow keys to control the snake.");
      addTerminalLine("Eat the food to grow and earn points.");
      
      // Show game container
      const gameContainer = document.getElementById('snake-game');
      gameContainer.style.display = 'flex';
      
      // Initialize game
      setTimeout(() => {
        snakeGame.init();
      }, 100);
      
      // Make pet react
      if (petVisible) {
        const petMouth = document.querySelector(".pet-mouth");
        const petEyes = document.querySelectorAll(".pet-eye");
        
        petMouth.className = "pet-mouth happy";
        petEyes.forEach(eye => eye.classList.add("happy"));
        
        showPetSpeech("Let's play Snake! Use arrow keys to control.", "GAME TIME");
      }
    }
    // BSOD Easter Egg
    function showBSOD() {
      // Create BSOD overlay
      const bsod = document.createElement("div");
      bsod.style.position = "fixed";
      bsod.style.top = "0";
      bsod.style.left = "0";
      bsod.style.width = "100vw";
      bsod.style.height = "100vh";
      bsod.style.backgroundColor = "#0078d7";
      bsod.style.color = "white";
      bsod.style.padding = "20% 10%";
      bsod.style.boxSizing = "border-box";
      bsod.style.fontFamily = "Segoe UI, sans-serif";
      bsod.style.fontSize = "1.5rem";
      bsod.style.zIndex = "9999";
      bsod.style.display = "flex";
      bsod.style.flexDirection = "column";
      bsod.style.alignItems = "center";
      bsod.style.justifyContent = "center";
      bsod.style.textAlign = "center";
      
      bsod.innerHTML = `
        <div style="font-size: 3rem; margin-bottom: 2rem;">:(</div>
        <div style="margin-bottom: 1rem;">Your PC ran into a problem and needs to restart.</div>
        <div style="margin-bottom: 2rem;">We're just collecting some error info, and then we'll restart for you.</div>
        <div style="margin-bottom: 1rem;">0% complete</div>
        <div style="font-size: 0.8rem; margin-top: 3rem;">
          <p>For more information about this issue and possible fixes, visit https://gl1tch0v3rr1d3.com/stop</p>
          <p>If you call a support person, give them this info:</p>
          <p>Stop code: CRITICAL_PROCESS_DIED</p>
        </div>
      `;
      
      document.body.appendChild(bsod);
      
      // Simulate progress
      let progress = 0;
      const progressText = bsod.querySelector("div:nth-child(4)");
      
      const progressInterval = setInterval(() => {
        progress += Math.random() * 5;
        if (progress > 100) progress = 100;
        
        progressText.textContent = `${Math.floor(progress)}% complete`;
        
        if (progress === 100) {
          clearInterval(progressInterval);
          setTimeout(() => {
            document.body.removeChild(bsod);
            // Auto-clear terminal and show reboot sequence
            simulateReboot();
          }, 1000);
        }
      }, 200);
    }
    
    // Simulate system reboot after BSOD
    function simulateReboot() {
      // Clear terminal
      terminal.textContent = "";
      
      // Disable command input during reboot
      const commandInput = document.getElementById("command-input");
      const commandButton = document.getElementById("command-button");
      commandInput.disabled = true;
      commandButton.disabled = true;
      
      // Show reboot sequence
      const rebootLines = [
        "System halted due to critical error.",
        "Initiating emergency recovery protocol...",
        "Checking file system integrity...",
        "Recovering system files...",
        "Restoring terminal environment...",
        "Loading kernel modules...",
        "Initializing system services...",
        "Mounting virtual filesystems...",
        "Starting network services...",
        "Performing security checks...",
        "System recovery complete.",
        "",
        "Gl1tch0v3rr1d3 Terminal v2.0",
        "Reboot successful. All systems operational.",
        "",
        "WARNING: Dangerous command execution detected.",
        "This incident has been logged.",
        "",
        "Type 'help' for available commands."
      ];
      
      // Display reboot lines with typing effect
      let lineIndex = 0;
      
      function typeRebootLine() {
        if (lineIndex < rebootLines.length) {
          addTerminalLine(rebootLines[lineIndex]);
          lineIndex++;
          setTimeout(typeRebootLine, 300);
        } else {
          // Re-enable command input after reboot
          commandInput.disabled = false;
          commandButton.disabled = false;
          commandInput.focus();
          
          // Announce reboot completion for screen readers
          announce("System rebooted successfully after critical error.");
        }
      }
      
      // Start typing reboot sequence
      typeRebootLine();
    }
    
    // Command history implementation
    let commandHistory = [];
    let historyIndex = -1;
    
    function setupCommandHistory() {
      const commandInput = document.getElementById("command-input");
      
      // Add event listener for arrow keys
      commandInput.addEventListener("keydown", function(e) {
        // Up arrow - navigate to previous command
        if (e.key === "ArrowUp") {
          e.preventDefault();
          if (commandHistory.length > 0) {
            // If we're at the current input, save it temporarily
            if (historyIndex === -1) {
              commandInput.dataset.currentInput = commandInput.value;
            }
            
            // Navigate up through history
            historyIndex = Math.min(commandHistory.length - 1, historyIndex + 1);
            commandInput.value = commandHistory[commandHistory.length - 1 - historyIndex];
            
            // Move cursor to end of input
            setTimeout(() => {
              commandInput.selectionStart = commandInput.selectionEnd = commandInput.value.length;
            }, 0);
          }
        }
        
        // Down arrow - navigate to next command
        else if (e.key === "ArrowDown") {
          e.preventDefault();
          if (historyIndex > 0) {
            // Navigate down through history
            historyIndex--;
            commandInput.value = commandHistory[commandHistory.length - 1 - historyIndex];
          } 
          else if (historyIndex === 0) {
            // Return to current input
            historyIndex = -1;
            commandInput.value = commandInput.dataset.currentInput || "";
            delete commandInput.dataset.currentInput;
          }
          
          // Move cursor to end of input
          setTimeout(() => {
            commandInput.selectionStart = commandInput.selectionEnd = commandInput.value.length;
          }, 0);
        }
      });
    }
    
    // Add command to history
    function addToCommandHistory(command) {
      // Don't add empty commands or duplicates of the last command
      if (command.trim() === "" || (commandHistory.length > 0 && commandHistory[commandHistory.length - 1] === command)) {
        return;
      }
      
      // Add command to history
      commandHistory.push(command);
      
      // Limit history size to 50 commands
      if (commandHistory.length > 50) {
        commandHistory.shift();
      }
      
      // Reset history index
      historyIndex = -1;
    }
    // Backdoor Easter Egg
    function showBackdoorAccess() {
      // Trigger multiple glitches
      for (let i = 0; i < 10; i++) {
        setTimeout(triggerGlitch, i * 100);
      }
      
      addTerminalLine("BACKDOOR ACCESS INITIATED");
      addTerminalLine("Bypassing security protocols...");
      
      runProgressOperation("Accessing system core", () => {
        addTerminalLine("");
        addTerminalLine("ACCESS GRANTED");
        addTerminalLine("Welcome to the system, Administrator.");
        addTerminalLine("This access has been logged and reported to the authorities.");
        addTerminalLine("Just kidding... or am I?");
        
        // Make pet react
        if (petVisible) {
          const petMouth = document.querySelector(".pet-mouth");
          const petEyes = document.querySelectorAll(".pet-eye");
          
          petMouth.className = "pet-mouth surprised";
          petEyes.forEach(eye => eye.classList.add("alert"));
          
          showPetSpeech("How did you know that command?", "SUSPICIOUS");
        }
      });
    }

    // Run a progress operation with callback
    function runProgressOperation(operationText, callback) {
      // Create a progress bar
      const progressContainer = document.createElement("div");
      progressContainer.className = "progress-container";
      progressContainer.setAttribute("role", "progressbar");
      progressContainer.setAttribute("aria-valuemin", "0");
      progressContainer.setAttribute("aria-valuemax", "100");
      progressContainer.setAttribute("aria-valuenow", "0");
      
      const progressBar = document.createElement("div");
      progressBar.className = "progress-bar";
      
      const progressText = document.createElement("div");
      progressText.className = "progress-text";
      progressText.textContent = "0%";
      
      progressBar.appendChild(progressText);
      progressContainer.appendChild(progressBar);
      terminal.appendChild(progressContainer);
      terminal.scrollTop = terminal.scrollHeight;
      
      // Announce operation start
      announce(`${operationText} started`);
      
      // Animate progress
      let progress = 0;
      const progressInterval = setInterval(() => {
        progress += Math.random() * 5;
        if (progress > 100) progress = 100;
        
        progressBar.style.width = `${progress}%`;
        progressText.textContent = `${Math.floor(progress)}%`;
        progressContainer.setAttribute("aria-valuenow", Math.floor(progress));
        
        if (progress === 100) {
          clearInterval(progressInterval);
          setTimeout(() => {
            // Remove progress bar
            terminal.removeChild(progressContainer);
            
            // Execute callback
            if (callback) callback();
            
            // Announce operation completion
            announce(`${operationText} completed`);
          }, 500);
        }
      }, 200);
    }

    // Digital pet functionality
    const petContainer = document.getElementById("pet-container");
    const pet = document.getElementById("pet");
    const petMenu = document.getElementById("pet-menu");
    const petSpeech = document.getElementById("pet-speech");
    
    // Pet random phrases
    const petPhrases = [
      "I detect unauthorized access attempts...",
      "System vulnerability detected in sector 7G",
      "Your firewall needs updating, human",
      "Scanning network for intrusions...",
      "Would you like me to encrypt that?",
      "01001000 01101001 00100001",
      "This connection is not secure",
      "Quantum encryption enabled",
      "Monitoring all frequencies",
      "Shall we play a game?",
      "I've seen things you wouldn't believe...",
      "All your base are belong to us",
      "The cake is a lie",
      "Have you tried turning it off and on again?",
      "Hack the planet!",
      "I know kung fu",
      "There is no spoon",
      "Follow the white rabbit",
      "Wake up, Neo...",
      "Reality is just electric signals interpreted by your brain"
    ];
    
    // Pet movement
    let petX = 20;
    let petY = window.innerHeight - 150;
    let targetX = petX;
    let targetY = petY;
    let petVisible = true;
    let petMoveInterval;
    let petSpeechInterval;
    
    function activatePet() {
      if (!petVisible) return;
      // Start pet movement
      if (!petMoveInterval) {
        petMoveInterval = requestAnimationFrame(movePet);
      }
      // Start random speech
      startRandomSpeech();
      
      // Announce pet activation for screen readers
      announce("Digital pet activated. It will move around the screen and occasionally speak.");
    }
    
    function movePet() {
      if (!petVisible) {
        petMoveInterval = requestAnimationFrame(movePet);
        return;
      }
      
      // Random movement
      if (Math.random() < 0.01 && !petMenu.style.display === "block") {
        // Set a new target position within screen bounds
        const maxX = window.innerWidth - 120;
        const minY = 100;
        const maxY = window.innerHeight - 150;
        
        // Ensure pet stays within viewport boundaries
        targetX = Math.max(20, Math.min(maxX, Math.random() * maxX));
        targetY = Math.max(minY, Math.min(maxY, Math.random() * maxY));
        
        // Change pet appearance based on movement
        if (targetX > petX) {
          // Moving right
          pet.style.transform = "scaleX(1)";
        } else {
          // Moving left
          pet.style.transform = "scaleX(-1)";
        }
      }
      
      // Smooth movement towards target
      petX += (targetX - petX) * 0.05;
      petY += (targetY - petY) * 0.05;
      
      // Boundary checking to prevent clipping outside viewport
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const petWidth = petContainer.offsetWidth;
      const petHeight = petContainer.offsetHeight;
      
      // Constrain to viewport boundaries
      petX = Math.max(0, Math.min(viewportWidth - petWidth, petX));
      petY = Math.max(0, Math.min(viewportHeight - petHeight - 50, petY)); // 50px buffer for status bar
      
      petContainer.style.transform = `translate(${petX - 20}px, ${petY - 20}px)`;
      
      petMoveInterval = requestAnimationFrame(movePet);
    }
    
    // Update pet boundaries on window resize
    window.addEventListener('resize', function() {
      // Recalculate boundaries
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const petWidth = petContainer.offsetWidth;
      const petHeight = petContainer.offsetHeight;
      
      // Ensure pet is within new boundaries
      petX = Math.max(0, Math.min(viewportWidth - petWidth, petX));
      petY = Math.max(0, Math.min(viewportHeight - petHeight - 50, petY));
      
      petContainer.style.transform = `translate(${petX - 20}px, ${petY - 20}px)`;
    });
    
    // Pet random speech
    function startRandomSpeech() {
      if (!petVisible) return;
      
      // Clear existing interval if any
      if (petSpeechInterval) clearTimeout(petSpeechInterval);
      
      // Random interval between 5-20 seconds
      const interval = 5000 + Math.random() * 15000;
      
      petSpeechInterval = setTimeout(() => {
        if (petVisible && !petMenu.style.display === "block") {
          // Show a random phrase
          showPetSpeech(petPhrases[Math.floor(Math.random() * petPhrases.length)]);
          
          // Hide speech after 3-5 seconds
          setTimeout(() => {
            hidePetSpeech();
          }, 3000 + Math.random() * 2000);
        }
        
        // Schedule next speech
        startRandomSpeech();
      }, interval);
    }
    
    // Show pet speech
    function showPetSpeech(text, title = "") {
      const contentDiv = petSpeech.querySelector(".pet-speech-content");
      const titleDiv = petSpeech.querySelector(".pet-speech-title");
      
      contentDiv.textContent = text;
      titleDiv.textContent = title;
      
      petSpeech.classList.add("show");
      
      // Position speech bubble relative to pet
      const petRect = petContainer.getBoundingClientRect();
      petSpeech.style.bottom = `${window.innerHeight - petRect.top + 10}px`;
      petSpeech.style.right = `${window.innerWidth - petRect.right + 20}px`;
      
      // Announce for screen readers
      announce(`Pet says: ${text}`);
    }
    
    // Hide pet speech
    function hidePetSpeech() {
      petSpeech.classList.remove("show");
    }
    
    // Setup pet speech close button
    const petSpeechCloseBtn = document.querySelector(".pet-speech-close");
    petSpeechCloseBtn.addEventListener("click", hidePetSpeech);
    petSpeechCloseBtn.addEventListener("keypress", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        hidePetSpeech();
      }
    });
    
    // Pet interaction
    petContainer.addEventListener("click", () => {
      if (petMenu.style.display === "block") {
        petMenu.style.display = "none";
      } else {
        petMenu.style.display = "block";
        // Position menu relative to pet
        const petRect = petContainer.getBoundingClientRect();
        petMenu.style.bottom = `${window.innerHeight - petRect.top + 10}px`;
        petMenu.style.right = `${window.innerWidth - petRect.right + 20}px`;
      }
    });
    
    // Pet menu actions
    document.querySelectorAll(".pet-action").forEach(action => {
      action.addEventListener("click", (e) => {
        const actionType = e.target.dataset.action;
        
        switch(actionType) {
          case "help":
            showPetSpeech("I can assist with system monitoring and security. Try clicking on the terminal for more information.");
            addTerminalLine("[PET] I can assist with system monitoring and security.");
            break;
          case "hack":
            showPetSpeech("Initiating system scan... Vulnerabilities detected in sector 7G.");
            addTerminalLine("[PET] Initiating system scan...");
            runProgressOperation("Analyzing system", () => {
              addTerminalLine("[PET] Scan complete. Vulnerabilities detected in sector 7G.");
            });
            break;
          case "play":
            // Pet animation
            pet.style.animation = "float 1s ease-in-out";
            setTimeout(() => {
              pet.style.animation = "";
            }, 1000);
            showPetSpeech("01001000 01100001 01110000 01110000 01111001 00100001");
            addTerminalLine("[PET] *happy digital noises*");
            break;
          case "hide":
            petVisible = false;
            petContainer.style.display = "none";
            if (petSpeechInterval) clearTimeout(petSpeechInterval);
            if (petMoveInterval) cancelAnimationFrame(petMoveInterval);
            petMoveInterval = null;
            addTerminalLine("[PET] Going to sleep mode. Type \"pet\" to wake me up.");
            break;
        }
        
        petMenu.style.display = "none";
      });
    });
    
    // Keyboard accessibility for pet menu
    document.querySelectorAll(".pet-action").forEach(action => {
      action.addEventListener("keypress", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          e.target.click();
        }
      });
    });
    
    // Status bar time update
    function updateTime() {
      const timeDisplay = document.getElementById("time-display");
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, "0");
      const minutes = String(now.getMinutes()).padStart(2, "0");
      const seconds = String(now.getSeconds()).padStart(2, "0");
      
      timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;
    }
    
    // Initialize everything
    window.addEventListener("DOMContentLoaded", () => {
      // Start typing animation
      typeLine();
      
      // Update time
      setInterval(updateTime, 1000);
      updateTime();
      
      // Announce page load for screen readers
      announce("Gl1tch0v3rr1d3 Terminal loaded. Initializing system.");
    });

    // Keyboard navigation improvements
    document.addEventListener("keydown", (e) => {
      // ESC key closes pet menu
      if (e.key === "Escape" && petMenu.style.display === "block") {
        petMenu.style.display = "none";
      }
      
      // P key toggles pet visibility
      if (e.key === "p") {
        processCommand("pet"); // Use the existing command logic
      }
    });

    // Terminal click handler
    terminal.addEventListener("click", () => {
      // Focus command input if it exists and is enabled
      const commandInput = document.getElementById("command-input");
      if (commandInput && !commandInput.disabled) {
        commandInput.focus();
      }
    });
  </script>
</body>
</html>
<!--Made by  ShadowRoot17-->
